import random
import timeit
from typing import List


# Сортування вставками
def insertion_sort(arr: List[int]) -> List[int]:

    # Ми припускаємо, що перший елемент (індекс 0) вже відсортований,
    # тому цикл починається з другого елемента (індекс 1).
    for i in range(1, len(arr)):

        # Ключовий елемент "key" буде вставлений у правильне місце в уже відсортованій частині списку.
        key = arr[i]

        # Для порівняння key з елементами, що передують йому,
        # iніціалізуємо j як індекс попереднього елемента відносно key.
        j = i - 1

        # Щоб вставити key у відсортовану частину списку,
        # ми порівнюємо його з кожним елементом, що передує йому,
        # починаючи з останнього елемента відсортованої частини (індекс j),
        # і аж до початку списку (j >= 0).
        while j >= 0 and key < arr[j]:
            # Зсуваємо arr[j] (попередній елемент) на одну позицію вправо, щоб звільнити місце для key.
            arr[j + 1] = arr[j]
            # Зменшуємо j, щоб продовжити порівняння з попередніми елементами.
            j -= 1

        # Після виходу з циклу while, j буде на 1 менше, ніж індекс, куди потрібно вставити key.
        arr[j + 1] = key
        # Вставляємо key на правильне місце в відсортованій частині списку.

    return arr


# Сортування злиттям
def merge_sort(arr: List[int]) -> List[int]:

    # Список з одним елементом сортування не потребує,
    # тому ми продовжуємо процес сортування, тільки якщо довжина списку більше 1.
    if len(arr) > 1:

        # Знаходимо середину списку, щоб розділити його на дві половини.
        mid = len(arr) // 2  # Цілочисельне ділення.

        # Створюємо ліву половину списку, яка містить елементи від початку до середини.
        left_half = arr[:mid]  # Список від початку до середини (не включаючи середину).

        # Права половина списку, яка містить елементи від середини до кінця.
        right_half = arr[mid:]  # Список від середини до кінця (включаючи середину!).

        # Рекурсивно сортуємо ліву половину списку.
        merge_sort(left_half)

        # Рекурсивно сортуємо праву половину списку.
        merge_sort(right_half)

        # Ініціалізуємо індекси i, j, k для проходження по лівій, правій половинах і злитому списку відповідно.
        i = j = k = 0

        while i < len(left_half) and j < len(right_half):
            # Поки є елементи в обох половинах, порівнюємо їх.
            if left_half[i] < right_half[j]:
                # Якщо елемент з лівої половини менший, додаємо його в злитий список.
                arr[k] = left_half[i]

                # Елемент з лівої половини був доданий в злитий список
                # (елементів у лівій половині стало на один менше),
                # тому переміщаємо індекс i на наступний елемент в лівій половині.
                i += 1

            else:
                # Якщо елемент з правої половини менший або рівний, додаємо його в злитий список.
                arr[k] = right_half[j]

                # Відповідно, елементів у правій половині стало на один менше,
                # тому переміщаємо індекс j на наступний елемент в правій половині.
                j += 1

            # Незалежно від того, який елемент був доданий в злитий список,
            # збільшуємо індекс k, щоб вставити наступний елемент на наступну позицію.
            k += 1

        # На випадок, якщо довжина списку непарна і
        # в результаті цілочисельного ділення залишились елементи в одній з половин,
        # додаємо останній елемент з цієї половини в кінець злитого списку.
        while i < len(left_half):  # У разі наявності, додаємо залишки з лівої половини.
            arr[k] = left_half[i]
            i += 1
            k += 1

        # Якщо є елементи в правій половині, додаємо їх.
        while j < len(right_half):
            arr[k] = right_half[j]
            j += 1
            k += 1

    return arr


def test_sorting_algorithms() -> None:
    sizes = [100, 1000, 10000]  # Розміри масивів для тестування
    repetitions = 5  # Кількість повторів для кожного тесту

    for size in sizes:
        # Генеруємо випадковий масив цілих чисел
        arr = [random.randint(0, size) for _ in range(size)]
        print(f"\nРозмір масиву: {size}")

        # Вимірюємо час сортування вставками
        insertion_time = timeit.timeit(
            lambda: insertion_sort(arr.copy()), number=repetitions
        )
        print(f"Сортування вставками: {insertion_time / repetitions:.6f} секунд")

        # Сортування злиттям
        merge_time = timeit.timeit(lambda: merge_sort(arr.copy()), number=repetitions)
        print(f"Сортування злиттям: {merge_time / repetitions:.6f} секунд")

        # Час сортування Timsort (вбудована функція sorted)
        timsort_time = timeit.timeit(lambda: sorted(arr.copy()), number=repetitions)
        print(f"Timsort: {timsort_time / repetitions:.6f} секунд")


if __name__ == "__main__":
    test_sorting_algorithms()


# Результати тестування (кількість повторів = 100):

# Розмір масиву: 100
# Сортування вставками: 0.000215 секунд
# Сортування злиттям: 0.000493 секунд
# Timsort: 0.000006 секунд

# Розмір масиву: 1000
# Сортування вставками: 0.022340 секунд
# Сортування злиттям: 0.004434 секунд
# Timsort: 0.000038 секунд

# Розмір масиву: 10000
# Сортування вставками: 2.339097 секунд
# Сортування злиттям: 0.050322 секунд
# Timsort: 0.000998 секунд

# Висновок:
# Сортування злиттям (merge sort) є більш ефективним, ніж сортування вставками (insertion sort),
# особливо для великих масивів. Але вбудована функція sorted (Timsort) є швидшою за інші випробувані тут алгоритми.
# Для практичного використання в реальних проектах варто використовувати вбудовані функції сортування Python (sort() або sorted()),
# оскільки вони реалізовані на основі Timsort і забезпечують найкращу продуктивність та ефективність для більшості випадків.
# https://docs.python.org/3.12/howto/sorting.html#sort-stability-and-complex-sorts
